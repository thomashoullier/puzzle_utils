:PROPERTIES:
:CATEGORY: puzzle_utils
:END:

* Project setup
** DONE Add options to the cmake build
CLOSED: [2023-10-28 Sat 20:49]
Currently when we load the library elsewhere, all the build targets
are also included, which is not what we want.

* Documentation
** Latex
*** TODO Introduce what are ranges, views, algorithms over them
See https://en.cppreference.com/w/cpp/ranges

*** DONE Printing a range
CLOSED: [2023-10-20 Fri 18:33]
Basic thing.

*** TODO Document our ex_range_printing example

*** TODO Document the ex_multiple example
*** DONE iota range factory
CLOSED: [2023-10-20 Fri 18:33]
+ See https://en.cppreference.com/w/cpp/ranges/iota_view
+ Run the example for real in an example section of the build.

*** TODO Create a range from a list of numbers manually.
initializer_list?

*** TODO filter range adaptor
+ See https://en.cppreference.com/w/cpp/ranges/filter_view

*** TODO fold_left
+ Used as a way to sum.

*** TODO accumulate

** Doxygen
*** DONE Create doxygen documention of pzu
CLOSED: [2023-10-28 Sat 08:02]
We require only a description of the API of pzu.


* Test suite
** DONE Initiate the test suite.
CLOSED: [2023-10-24 Tue 21:31]
Create the test suite with the existing pzu library examples.

** DONE Add test coverage utility
CLOSED: [2023-10-27 Fri 15:39]

** DONE Test suite in CI
CLOSED: [2023-10-28 Sat 20:26]
** DONE Add the non-regression test case on print
CLOSED: [2023-10-25 Wed 19:18]
This is:

#+begin_src C++
  auto even = [](int i) { return 0 == i % 2; };
  std::views::iota(1,20) | std::views::filter(even) | pzu::rangePrinter;
#+end_src

** TODO Silence cout in the tests for RangePrinter
RangePrinter works as intended, we want it to output to cout and only there
for simplicity.
But we do not want it to add noise in the test report.

+ ~std::cout.rdbuf(NULL)~ does not work: we still see the same output.
+ ~std::cout.setstate(std::ios_base::failbit);~  does not work either.
+ Where does ~fmt::print~ goes by default? I think to cstdio stdout, try
  disconnecting this.


* Functions to implement
** DONE Create a library with its own namespace
CLOSED: [2023-10-22 Sun 17:28]
** DONE Predicate for "is multiple of X"
CLOSED: [2023-10-25 Wed 20:03]
Features:
+ Must be used like: ~| std::views::filter(pzu::is_multiple_of(5,3))~
+ We can do a variadic function, for multiple of X, Y, Z etc.
+ Generalize to all valid inputs for the ~%~ operator, try using an auto,
  or if it fails, an integral type.
** DONE Generalize is_multiple_of to && and ||
CLOSED: [2023-10-29 Sun 09:32]
We may want all the numbers which are simultaneously the multiples of
the given arguments, or which are the multiple of at least one of the arguments.
Call it maybe like this: ~pzu::is_multiple_of<and>(3,5)~,
~pzu::is_multiple_of<or>(3,5)~.
-> In fact we did not find a way to pass ~and~ or ~or~ to a template, we wrote
dedicated functions ~all~ and ~any~.

** TODO Think about a generalization of checking a binary predicate with any or all arguments.
It would be called like so: ~is<multiple><all>(3,5)~.
Only implement it when we encounter another predicate such as ~multiple~.
Is there already something similar in the standard?

** TODO Unbounded sequence for Fibonacci Can probably look like this, thank you
LLMs. #+begin_src C++ #include <iostream> #include <vector> #include <ranges>
class FibonacciIterator { public: FibonacciIterator() : a(0), b(1) {} int
operator*() { return a; } FibonacciIterator& operator++() { int temp = a; a = b;
b += temp; return *this; } bool operator!=(const FibonacciIterator& other) const
{ return a != other.a; } private: int a, b; }; class FibonacciRange { public:
FibonacciRange() = default; FibonacciIterator begin() { return
FibonacciIterator(); } FibonacciIterator end() { // In a real use case, you'd
have to decide when to stop generating Fibonacci numbers // For this example,
we'll just return an iterator that never ends return FibonacciIterator(); } };
int main() { FibonacciRange fibonacci; for (int x : fibonacci |
std::views::take(10)) { std::cout << x << " "; } return 0; } #+end_src
** DONE Printing a view
CLOSED: [2023-10-22 Sun 17:28]
Implement a utility for printing views.
+ Features:
  + OK. Usage with the pipe syntax.
  + OK. Gives back the range at the other end of the pipe.
  + OK. Guard against infinite printing.
  + OK. Add the possibility of printing the first n elements for unbounded ranges.
  + OK. Replace std::enable_if_t with C++20 concepts.
+ Relevant links:
  + https://stackoverflow.com/questions/65676338/writing-a-c20-range-to-standard-output
  + https://stackoverflow.com/questions/74074633/how-do-you-make-a-pipeable-function-like-rangestot-with-range-v3-ranges

** TODO Add the option for RangePrinter to print to a different output stream.
+ The default must still be std::cout.
+ We must still be able to call ~pzu::RangePrinter(10)~.
+ Call like ~pzu::RangePrinter(std::cout, 10)~ by overloading.

* Maintenance
** HOLD Replace the external fmt library with the standard C++ when it becomes available
+ Use the C++23 <print> header when it becomes implemented in gcc.
  See https://en.cppreference.com/w/cpp/compiler_support/23

** DONE Bug in RangePrinter
CLOSED: [2023-10-23 Mon 21:18]
The following does not seem to work:
~std::views::iota(1,20) | std::views::filter(is_multiple_of_2) | pzu::rangePrinter~

+ This is not a SizedRange since it does not know its size in constant time.
+ Add the bug to a non-regression test.

We have solved the bug by changing the print RangePrinter method from:
~print (const View auto &range)~ to ~print (View auto range)~.
I think the reason may be that some ranges do need to modify their state
in order to know their length?
